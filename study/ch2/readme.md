# 2: Learning about Toolchains

## Thechnical References:


## Building toolchain

- Install linux dependencies:
```bash
$ sudo apt-get install autoconf automake bison bzip2 cmake \
flex g++ gawk gcc \
gettext git gperf help2man libncurses5-dev libstdc++6 libtool \
libtool-bin make \
patch python3-dev rsync texinfo unzip wget xz-utils
```

- Generic `gcc` command to dump toolchain tuple
    - names each tool that composes the toolchain (cpu-kernel-userSpace)
```bash
$ gcc -dumpmachine 
x86_64-linux-gnu
```

- There are a couple of options when deciding where to get the toolchain from

    - Download an already built toolchain

    - Use the one generated by one build system (buildroot / yocto)

    - Generate your own

- When downloading an already built toolchain you may find yourself limited in customization and support for future updates

- Building a toolchain by hand is no easy task 

    - There is a project that goes through the steps of cross compiling each component

    - It is the "Cross Linux from Scratch (CLFS)" - https://trac.clfs.org

- `crosstool-ng` is a tool that encapsulates that process into a set of scripts and menus


- Clone, build and install crosstool-ng:
```bash
ggm@gAN515-52:~/embedded-linux $ git clone https://github.com/crosstool-ng/crosstool-ng.git
Cloning into 'crosstool-ng'...
remote: Enumerating objects: 43493, done.
remote: Counting objects: 100% (1527/1527), done.
remote: Compressing objects: 100% (729/729), done.
remote: Total 43493 (delta 794), reused 1401 (delta 770), pack-reused 41966
Receiving objects: 100% (43493/43493), 15.93 MiB | 8.31 MiB/s, done.
Resolving deltas: 100% (27536/27536), done.
ggm@gAN515-52:~/embedded-linux $ cd crosstool-ng/
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ git log -n1 --oneline --decorate
76758ddd (HEAD -> master, origin/master, origin/HEAD) glibc: Fix THREAD_SETMEM/THREAD_SETMEM_NC for movq in x86_64
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ ./bootstrap 
INFO  :: *** Generating package version descriptions
INFO  :: Master packages: autoconf automake avr-libc binutils bison cloog dtc duma elf2flt expat gcc gdb gettext glibc gmp gnuprumcu isl libelf libiconv libtool linux ltrace m4 make mingw-w64 moxiebox mpc mpfr musl ncurses newlib-nano newlib picolibc strace uClibc-ng zlib zstd
INFO  :: Generating 'config/versions/autoconf.in'
...
INFO  :: *** Gathering the list of data files to install
INFO  :: *** Running autoreconf
INFO  :: *** Done!
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ ./configure --prefix=${PWD}
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a race-free mkdir -p... /usr/bin/mkdir -p
...
config.status: creating config/configure.in
config.status: creating config.h
config.status: executing depfiles commands
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ make
/usr/bin/gmake  all-recursive
gmake[1]: Entering directory '/home/ggm/embedded-linux/crosstool-ng'
Making all in kconfig
...
  GEN      docs/ct-ng.1
gmake[2]: Leaving directory '/home/ggm/embedded-linux/crosstool-ng'
gmake[1]: Leaving directory '/home/ggm/embedded-linux/crosstool-ng'
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ make install
Making install in kconfig
gmake[1]: Entering directory '/home/ggm/embedded-linux/crosstool-ng/kconfig'
/usr/bin/gmake  install-am
...
gmake[3]: Leaving directory '/home/ggm/embedded-linux/crosstool-ng'
gmake[2]: Leaving directory '/home/ggm/embedded-linux/crosstool-ng'
gmake[1]: Leaving directory '/home/ggm/embedded-linux/crosstool-ng'
```

- The executable will be available:
```bash
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ md5sum bin/ct-ng 
6a529d76f3fc6985f578dddcf522ffd7  bin/ct-ng
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ md5sum ct-ng
6a529d76f3fc6985f578dddcf522ffd7  ct-ng
```

- There are already sample configurations available for common toolchains:

    - `$ ./ct-ng list-samples`

- BeagleBone Black has Texas Instrument's AM335x SOC (ARM Cortex A8, VFPv3 floating point unit)

- Show specific information about one of the sample configurations:
```bash
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ ./ct-ng show-arm-cortex_a8-linux-gnueabi
[L...]   arm-cortex_a8-linux-gnueabi
    Languages       : C,C++
    OS              : linux-6.6.1
    Binutils        : binutils-2.41
    Compiler        : gcc-13.2.0
    C library       : glibc-2.38
    Debug tools     : duma-2_5_21 gdb-14.1 ltrace-0.7.3 strace-6.6
    Companion libs  : expat-2.5.0 gettext-0.21 gmp-6.2.1 isl-0.26 libelf-0.8.13 libiconv-1.16 mpc-1.3.1 mpfr-4.2.1 ncurses-6.4 zlib-1.3 zstd-1.5.5
    Companion tools :
```

- We'll use this as the starting point, and edit some configurations via menuconfig

- "Activate" this specific target toolchain configuration in the current shell context (this will write the configuration into `.config`)
```bash
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ ./ct-ng arm-cortex_a8-linux-gnueabi
  CONF  arm-cortex_a8-linux-gnueabi
#
# configuration written to .config
#

***********************************************************

Initially reported by: Yann E. MORIN
URL: http://ymorin.is-a-geek.org/

***********************************************************

Now configured for "arm-cortex_a8-linux-gnueabi"
```


- At this point, it's possible to open menuconfig to allow for visual customization of the toolchain:

    - `./ct-ng menuconfig`

- We'll change:

    - In Paths and misc options, disable Render the toolchain read-only (CT_PREFIX_DIR_RO).

    - In Target options | Floating point, select hardware (FPU) (CT_ARCH_FLOAT_HW).

    - In Target options, enter neon for Use specific FPU.

```bash
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ ./ct-ng menuconfig
  CONF  menuconfig
configuration written to .config

*** End of the configuration.
*** Execute 'ct-ng build' to start the build or try 'ct-ng help'.
```

- Build the toolchain configured in the `.config` file:

    - `./ct-ng build`

- The built toolchain will be present in `~/x-tools/arm-cortex_a8-linux-gnueabihf/bin`

    - This is where the toolchain elements (like the cross compiler) will be present:
    
        - `ll ~/x-tools/arm-cortex_a8-linux-gnueabihf/bin/arm-cortex_a8-linux-gnueabihf-gcc`

- Deactivate the current toolchain configuration in the current shell context:

    - `$ ./ct-ng distclean`

- Looks like the build directories and all the downloads took ~12GB disk space, whereas the toolchain itself (under ~/x-tools directory) takes only around 500MB
```bash
ggm@gAN515-52:~/embedded-linux/crosstool-ng (master)$ du -h --max-depth=1 .
1,1M	./config
44K	./debian
2,7M	./autom4te.cache
1,5M	./samples
444K	./testing
240K	./m4
120K	./licenses.d
4,4M	./kconfig
28K	./docs
2,4M	./include
16K	./bin
12M	./packages
24K	./.github
12G	./.build
1,5M	./libexec
20K	./contrib
15M	./share
880K	./scripts
12K	./bash-completion
108K	./maintainer
18M	./.git
12G	.
ggm@gAN515-52:~/x-tools/arm-cortex_a8-linux-gnueabihf $ du -h --max-depth=1 .
28M	./lib
4,0K	./include
73M	./bin
193M	./arm-cortex_a8-linux-gnueabihf
96M	./libexec
2,8M	./share
393M	.
```

- The book also builds a toolchain specifically for using with QEMU, which is based on a different target (ARM926EJ-S)
<!-- Can't I use the same toolchain generated previously for BBB with QEMU? -->


## Using toolchain

- Adding the toolchain installation directory to the PATH:

    - `PATH=${HOME}/x-tools/arm-cortex_a8-linux-gnueabihf/bin/:$PATH`

- Compiling a simple helloworld.c:

    - `arm-cortex_a8-linux-gnueabihf-gcc helloworld.c -o helloworld`

- Inspecting the compiled file to know more about it:

    - `file helloworld`

```bash
ggm@gAN515-52:~/embedded-linux/hello-world-app $ echo '#include <stdio.h>
#include <stdlib.h>
int main (int argc, char *argv[])
{
    printf ("Hello, world!\n");
    return 0;
}' > hello-world.c
ggm@gAN515-52:~/embedded-linux/hello-world-app $ PATH=${HOME}/x-tools/arm-cortex_a8-linux-gnueabihf/bin/:$PATH
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-gcc hello-world.c -o hello-world
ggm@gAN515-52:~/embedded-linux/hello-world-app $ file hello-world
hello-world: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 6.6.1, with debug_info, not stripped
```

- Inspecting the copiler to know more about the toolchain being used:

    - Version:

        - `arm-cortex_a8-linux-gnueabihf-gcc --version`

    - How it was configured:

        - `arm-cortex_a8-linux-gnueabihf-gcc -v`

    - The output will tell us about:
    
        - The `sysroot` directory (`--with-sysroot`)

        - Languages enabled (`--enable-languages`)

        - Default target cpu (`--with-cpu`)

        - etc


- Some of these default settings are overwrittable, for instance, it's possible to compile for a slightly different CPU by doing:

    - `arm-cortex_a8-linux-gnueabihf-gcc -mcpu=cortex-a5 helloworld.c -o helloworld`

    - Can list the possible targets with: `arm-cortex_a8-linux-gnueabihf-gcc --target-help`

    - You can keep the toolchain always specific and tied to the target architecture OR use one toolchain in a more generic way, just changing the target like shown above. It's a project decision and there is drawbacks and advantages.

### sysroot directory
- In the example, sysroot directory is:

    - `~/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot`

- This directory contains subdirectories for header files, libraries, configuration files

    - `lib` contains shared objects (*.a, *.so) for the C library and the dynamic linker

    - `usr/lib` is the static library archive (*.a, *.so) for the C library

    - `usr/include` contains the headers (*.h) themselves

    - `usr/bin` utilities programs that run on the target like "ldd"

    - `usr/share`

    - `sbin` ldconfig utility

- Some of these are needed on the development host to compile programs (ex: headers)

- Some of these are needed on the target at run time (ex: shared libraries and ld-linux)

- Example showing some of the components fo the C library:
```bash
ggm@gAN515-52:~/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot $ find . -iname "*libm*"
./usr/lib/libmcheck.a
./usr/lib/libmenu.so.6
./usr/lib/libm.a
./usr/lib/libm.so
./usr/lib/libmpfr.a
./usr/lib/libmenu.so.6.4
./usr/lib/libmenu.a
./usr/lib/libmenu.so
./usr/lib/libmpfr.la
./usr/include/bits/libm-simd-decl-stubs.h
./lib/libmemusage.so
./lib/libm.so.6
```

### libc components

- 4 main components

    - `libc`: main lib that contains the POSIX functions (prinf, open, close, read, write)

    - `libm`: math functions (cos, exp, log)

    - `libpthread`: POSIX thread functions

    - `librt`: real time extension to POSIX (shared memory, async i/o)


- `libc` component is always linked by default to programs

- The other components have to be explicitly linked with the -l option (excluding the "lib" part of the name, like so: `-lm` to link libm)

- List which libraries have been linked in a target file, do:

    - `arm-cortex_a8-linux-gnueabihf-readelf -a myprog | grep "Shared library"`

- Shared libraries need a runtime linker. List the runtime linker:

    - `arm-cortex_a8-linux-gnueabihf-readelf -a myprog | grep "program interpreter"`

```bash
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-readelf -a hello-world | grep Shared
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-readelf -a hello-world | grep interpreter
      [Requesting program interpreter: /lib/ld-linux-armhf.so.3]
```

### Static Link
- All the library functions your application calls and their dependencies are pulled from the library archive and bound into your executable

- Extension will be "*.a" (from archive)

- Use cases:

    - If you are building a small system with only busybox + couple of scripts

        - It is simpler to link the C library with busybox statically and avoid having to copy the runtime library and linker

        - The system will also have a smaller footprint, because it'll only link the code that it actually uses, rather then suplying the entire C library

    - If you need a program to run before the filesystem that holds the runtime libraryes is up, you'll need static link

- Compiling hello-world.c and statically linking

```bash
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-gcc -static hello-world.c -o hello-world-static
# It is way bigger then dynamic link because it'll be a "stand-alone" binary which contains all the code it 
# uses in itself, not having any runtime dependencies
ggm@gAN515-52:~/embedded-linux/hello-world-app $ du -h hello-world*
12K	hello-world
4,0K	hello-world.c
2,8M	hello-world-static
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-readelf -a hello-world | grep Shared
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-readelf -a hello-world-static | grep Shared
```

- Sample makefile to produce static library:

    - Source: *Mastering-Embedded-Linux-Programming-Third-Edition/Chapter02/library/static/Makefile*

    - Use `ar` application to generate "archive" based on compiled object

```makefile
CFLAGS = -Wall -g -I../inc
OBJECTS = testlib.o
 
all: libtest.a

# Build the static library
libtest.a: $(OBJECTS)
	ar rc libtest.a $(OBJECTS)

testlib.o: testlib.c
	$(CC) $(CFLAGS) -c testlib.c

clean:
	rm -f $(OBJECTS)
	rm -f libtest.a
```

- Sample makefile to link that library statically:

```makefile
CFLAGS := -c -Wall -I../inc
PROGS := hello-arm-static

all: $(PROGS)

hello-arm.o: hello-arm.c
	$(CC) $(CFLAGS) -o $@ $^

hello-arm-static: hello-arm.o
#	$(CC) $(LDFLAGS) -o $@ $^ ../static/libtest.a
	$(CC) -o $@ $^ -L../static -ltest

clean:
	rm -f *.o
	rm -f $(PROGS)

install:
	cp $(PROGS) $(TARGET_DIR)/usr/local/bin
```

### Dynamic Link
- References to the library files and functions in those files are generated in the code but the actual is done dynamically at runtime

- Extension will be "*.so" (from shared ojbect)

- Advantages include:

    - More efficient usage of storage / system memory

    - Don't need to recompile all applications that depend on a library if the library changes. You can just replace the "*.so" file

- In the case of our system, the runtime linker is `/lib/ld-linux-armhf.so.3`:

    - It'll in runtime look for the "*.so" shared objects in certain specific paths, and perform the link

```bash
ggm@gAN515-52:~/embedded-linux/hello-world-app $ arm-cortex_a8-linux-gnueabihf-readelf -a hello-world | grep interpreter
      [Requesting program interpreter: /lib/ld-linux-armhf.so.3]
```

- Sample makefile to produce shared library:

    - Source: *Mastering-Embedded-Linux-Programming-Third-Edition/Chapter02/library/shared/Makefile*

```makefile
# The object code for a shared library must be position-independent, so that the runtime
# linker is free to locate it in memory at the next free address. To do this, add the -fPIC option

CFLAGS := -Wall -g -fPIC -I../inc
OBJECTS := testlib.o
 
all: libtest.so

# Build the shared library
libtest.so: $(OBJECTS)
	$(CC) -shared -o libtest.so $(OBJECTS)

testlib.o: testlib.c
	$(CC) $(CFLAGS) -c testlib.c

clean:
	rm -f $(OBJECTS)
	rm -f libtest.so
```


- Sample makefile to link that library dynamically:

```makefile
CFLAGS := -c -Wall -I../inc
PROGS := hello-arm-shared

all: $(PROGS)

hello-arm.o: hello-arm.c
	$(CC) $(CFLAGS) -o $@ $^

hello-arm-shared: hello-arm.o
	$(CC) -o $@ $^ -L../shared -ltest

clean:
	rm -f *.o
	rm -f $(PROGS)

install:
	cp $(PROGS) $(TARGET_DIR)/usr/local/bin


```

### Libraries versions and names
- libjpeg.a: This is the library archive used for static linking.

- libjpeg.so -> libjpeg.so.8.2.2: This is a symbolic link, used for dynamic linking.

- libjpeg.so.8 -> libjpeg.so.8.2.2: This is a symbolic link, used when loading the library at runtime.

- libjpeg.so.8.2.2: This is the actual shared library, used at both compile time and runtime.

- The first two are only needed on the host computer for building and the last two are needed on the target at runtime

### Automating the usage of the toolchain
- Script to activate cross-environment:
    ```bash
    PATH=${HOME}/x-tools/arm-cortex_a8-linux-gnueabihf/bin/:$PATH
    export CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-
    export ARCH=arm
    ```

    - `CROSS_COMPILE` is a makefile variable